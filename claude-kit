#!/usr/bin/env python3
"""claude-kit — Claude Code plugin manager"""

import sys
import os
import json
import subprocess
import shutil
import pathlib
import difflib
from datetime import datetime

# ── Constants ────────────────────────────────────────────────────────────────

INSTALL_DIR      = pathlib.Path(os.path.realpath(__file__)).parent
PLUGINS_DIR      = INSTALL_DIR / "plugins"
LOCAL_DIR        = INSTALL_DIR / "local" / "plugins"
INSTALLED_MARKER = INSTALL_DIR / ".installed"
MANIFEST_FILE    = INSTALL_DIR / "local" / "setup-manifest.json"
BACKUP_DIR       = INSTALL_DIR / "local" / "backups"

CK_MODE       = "user" if INSTALLED_MARKER.exists() else "dev"
CK_OUTPUT_DIR = LOCAL_DIR if CK_MODE == "user" else PLUGINS_DIR

# ── Colors ───────────────────────────────────────────────────────────────────

class C:
    R   = '\033[0;31m'
    G   = '\033[0;32m'
    Y   = '\033[0;33m'
    CY  = '\033[0;36m'
    W   = '\033[1;37m'
    DIM = '\033[2m'
    N   = '\033[0m'

def col(color: str, text: str) -> str:
    return f"{color}{text}{C.N}"

def p(text: str = "") -> None:
    print(text)

# ── Plugin helpers ────────────────────────────────────────────────────────────

def plugin_version(plugin_dir: pathlib.Path) -> str:
    pjson = plugin_dir / ".claude-plugin" / "plugin.json"
    if not pjson.exists():
        return "?"
    try:
        return json.loads(pjson.read_text()).get("version", "?")
    except Exception:
        return "?"

def find_plugin_dir(name: str):
    for base in [PLUGINS_DIR, LOCAL_DIR]:
        d = base / name
        if d.is_dir():
            return d
    return None

def resolve_prefix(prefix: str) -> list:
    results = []
    for base in [PLUGINS_DIR, LOCAL_DIR]:
        if base.exists():
            for d in sorted(base.iterdir()):
                if d.is_dir() and d.name.startswith(prefix + "-"):
                    results.append(d.name)
    return results

def resolve_companions(plugin_dir: pathlib.Path) -> list:
    ctl = plugin_dir / ".claude-plugin" / "ctl.json"
    if not ctl.exists():
        return []
    try:
        return json.loads(ctl.read_text()).get("companions", [])
    except Exception:
        return []

def expand_kit(kit_name: str, seen: set) -> list:
    """Expand a kit name into deduplicated plugin names, companions first."""
    prefix_result = resolve_prefix(kit_name)
    plugin_names = prefix_result if prefix_result else [kit_name]

    result = []
    for pname in plugin_names:
        pdir = find_plugin_dir(pname)
        if pdir is None:
            print(f"Error: Kit '{pname}' not found in {PLUGINS_DIR}/ or {LOCAL_DIR}/",
                  file=sys.stderr)
            p()
            cmd_list()
            sys.exit(1)

        for comp in resolve_companions(pdir):
            if comp not in seen:
                comp_dir = find_plugin_dir(comp)
                if comp_dir is None:
                    print(f"Warning: Companion '{comp}' (required by '{pname}') not found.",
                          file=sys.stderr)
                else:
                    seen.add(comp)
                    result.append(comp)

        if pname not in seen:
            seen.add(pname)
            result.append(pname)

    return result

# ── cmd_run ───────────────────────────────────────────────────────────────────

def cmd_run(args: list) -> None:
    kit_names = []
    model = "opus"
    skip_permissions = False

    i = 0
    while i < len(args):
        a = args[i]
        if a in ("--kit", "-k"):
            i += 1
            if i >= len(args):
                print("Error: --kit requires a name"); sys.exit(1)
            kit_names.append(args[i])
        elif a in ("--model", "-m"):
            i += 1
            if i >= len(args):
                print("Error: --model requires a value"); sys.exit(1)
            model = args[i]
        elif a in ("--dangerously-skip-permissions", "--yolo", "-y"):
            skip_permissions = True
        elif a.startswith("-"):
            print(f"Unknown flag: {a}")
            print("Run 'claude-kit help' for usage.")
            sys.exit(1)
        else:
            kit_names.append(a)
        i += 1

    if not kit_names:
        print("Error: Specify at least one kit with --kit <name>")
        p()
        cmd_list()
        sys.exit(1)

    seen: set = set()
    all_plugins: list = []
    for name in kit_names:
        all_plugins.extend(expand_kit(name, seen))

    os.environ["CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS"] = "1"
    os.environ["CLAUDE_KIT_HOME"]        = str(INSTALL_DIR)
    os.environ["CLAUDE_KIT_BUNDLED_DIR"] = str(PLUGINS_DIR)
    os.environ["CLAUDE_KIT_LOCAL_DIR"]   = str(LOCAL_DIR)
    os.environ["CLAUDE_KIT_OUTPUT_DIR"]  = str(CK_OUTPUT_DIR)
    os.environ["CLAUDE_KIT_MODE"]        = CK_MODE

    LOCAL_DIR.mkdir(parents=True, exist_ok=True)

    claude_args = ["claude"]
    for pname in all_plugins:
        pdir = find_plugin_dir(pname)
        claude_args.extend(["--plugin-dir", str(pdir)])
    claude_args.extend(["--model", model])

    if skip_permissions:
        claude_args.append("--dangerously-skip-permissions")
        print("Warning: Running with --dangerously-skip-permissions")

    if len(all_plugins) > 1:
        print(f"Loading: {', '.join(all_plugins)}")

    os.execvp("claude", claude_args)

# ── cmd_list ──────────────────────────────────────────────────────────────────

def cmd_list() -> None:
    p(col(C.W, "Bundled kits:"))
    if PLUGINS_DIR.exists():
        kits = [d for d in sorted(PLUGINS_DIR.iterdir()) if d.is_dir()]
        for d in kits:
            p(f"  {d.name}")
        if not kits:
            p("  (none)")
    else:
        p("  (none)")

    p()
    p(col(C.W, "Local kits:"))
    if LOCAL_DIR.exists():
        local_kits = [d for d in sorted(LOCAL_DIR.iterdir()) if d.is_dir()]
        if local_kits:
            for d in local_kits:
                p(f"  {d.name}")
        else:
            p("  (none — run 'claude-kit --kit system-maker' to create one)")
    else:
        p("  (none — run 'claude-kit --kit system-maker' to create one)")

    # Shortcuts: group plugins sharing a prefix (2+)
    if PLUGINS_DIR.exists():
        prefix_map: dict = {}
        for d in sorted(PLUGINS_DIR.iterdir()):
            if not d.is_dir():
                continue
            parts = d.name.split("-")
            if len(parts) > 1:
                prefix = "-".join(parts[:-1])
                prefix_map.setdefault(prefix, []).append(d.name)

        shortcuts = {k: v for k, v in prefix_map.items() if len(v) >= 2}
        if shortcuts:
            p()
            p(col(C.W, "Shortcuts (loads full group):"))
            for prefix, members in sorted(shortcuts.items()):
                p(f"  {prefix} → [{', '.join(sorted(members))}]")


# ── cmd_update ────────────────────────────────────────────────────────────────

def _git(args: list) -> str:
    return subprocess.run(
        ["git", "-C", str(INSTALL_DIR)] + args,
        capture_output=True, text=True
    ).stdout.strip()

def cmd_update() -> None:
    p()
    p(f"  {col(C.W, 'claude-kit update')}")
    p(f"  {col(C.DIM, '─' * 40)}")
    p()

    old_versions: dict = {}
    if PLUGINS_DIR.exists():
        for d in sorted(PLUGINS_DIR.iterdir()):
            if d.is_dir():
                old_versions[d.name] = plugin_version(d)

    old_ref = _git(["rev-parse", "--short", "HEAD"]) or "?"

    p(f"  {col(C.CY, 'Pulling from origin...')}")
    p()

    result = subprocess.run(
        ["git", "-C", str(INSTALL_DIR), "pull", "--ff-only"],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        p(f"  {col(C.R, '✗ Pull failed')}")
        p()
        for line in (result.stdout + result.stderr).splitlines():
            p(f"    {line}")
        p()
        sys.exit(1)

    new_ref = (_git(["describe", "--tags", "--always"])
               or _git(["rev-parse", "--short", "HEAD"])
               or "?")

    if "Already up to date" in (result.stdout + result.stderr):
        p(f"  {col(C.G, '✓ Already up to date')}  {col(C.DIM, f'({new_ref})')}")
        p()
        return

    n_commits = _git(["rev-list", f"{old_ref}..HEAD", "--count"]) or "?"
    commit_word = "commit" if n_commits == "1" else "commits"
    p(f"  {col(C.G, '✓ Updated to')} {col(C.W, new_ref)}  {col(C.DIM, f'({n_commits} new {commit_word})')}")
    p()

    new_versions: dict = {}
    if PLUGINS_DIR.exists():
        for d in sorted(PLUGINS_DIR.iterdir()):
            if d.is_dir():
                new_versions[d.name] = plugin_version(d)

    all_names = set(old_versions) | set(new_versions)
    max_len = max((len(n) for n in all_names), default=0)

    p(f"  {col(C.W, 'Plugin versions:')}")
    p()

    shown: set = set()
    for name in sorted(new_versions):
        ov = old_versions.get(name)
        nv = new_versions[name]
        pad = " " * (max_len - len(name))
        if ov is None:
            p(f"    {col(C.G, '+')} {col(C.W, name)}{pad}  {col(C.G, nv)}  {col(C.DIM, '(new)')}")
        elif ov != nv:
            p(f"    {col(C.Y, '↑')} {col(C.W, name)}{pad}  {col(C.Y, f'{ov} → {nv}')}")
        else:
            p(f"    {col(C.DIM, f'  {name}{pad}  {nv}')}")
        shown.add(name)

    for name in sorted(old_versions):
        if name not in shown:
            pad = " " * (max_len - len(name))
            p(f"    {col(C.R, '-')} {name}{pad}  {col(C.R, '(removed)')}")

    # Auto-update statusline script if installed
    sl_dest = pathlib.Path.home() / ".claude" / "statusline-command.sh"
    sl_src  = INSTALL_DIR / "scripts" / "statusline-command.sh"
    if sl_dest.exists() and sl_src.exists():
        if sl_src.read_bytes() != sl_dest.read_bytes():
            shutil.copy2(sl_src, sl_dest)
            p()
            p(f"  {col(C.W, 'Scripts:')}")
            p()
            p(f"    {col(C.Y, '↑')} {col(C.W, 'statusline-command.sh')}  {col(C.Y, 'updated')}")

    p()
    p(f"  {col(C.G, 'Done.')}")
    p()

# ── cmd_validate ──────────────────────────────────────────────────────────────

def cmd_validate(args: list) -> None:
    if not args:
        print("Usage: claude-kit validate <name>")
        sys.exit(1)

    name = args[0]
    plugin_dir = find_plugin_dir(name)
    if plugin_dir is None:
        print(f"Error: '{name}' not found in {PLUGINS_DIR}/ or {LOCAL_DIR}/")
        sys.exit(1)

    print(f"Validating: {name}")
    p()
    errors = 0

    pjson = plugin_dir / ".claude-plugin" / "plugin.json"
    if pjson.exists():
        print("  [OK] .claude-plugin/plugin.json exists")
        try:
            json.loads(pjson.read_text())
        except json.JSONDecodeError:
            print("  [FAIL] plugin.json is not valid JSON")
            errors += 1
    else:
        print("  [FAIL] .claude-plugin/plugin.json MISSING (required)")
        errors += 1

    for dirname in ["commands", "agents", "skills", "hooks"]:
        d = plugin_dir / dirname
        if d.exists():
            count = sum(1 for _ in d.rglob("*") if _.is_file())
            print(f"  [OK] {dirname}/ ({count} files)")
        else:
            print(f"  [--] {dirname}/ (optional)")

    hooks_json = plugin_dir / "hooks" / "hooks.json"
    if hooks_json.exists():
        try:
            data = json.loads(hooks_json.read_text())
            hooks = data.get("hooks", data)
            if isinstance(hooks, dict):
                print("  [OK] hooks/hooks.json uses event-based keys")
            elif isinstance(hooks, list):
                print("  [WARN] hooks/hooks.json needs event-based keys")
                errors += 1
        except json.JSONDecodeError:
            print("  [FAIL] hooks/hooks.json invalid JSON")
            errors += 1

    ctl_json = plugin_dir / ".claude-plugin" / "ctl.json"
    if ctl_json.exists():
        try:
            data = json.loads(ctl_json.read_text())
            for comp in data.get("companions", []):
                if find_plugin_dir(comp):
                    print(f"  [OK] companion '{comp}' exists")
                else:
                    print(f"  [FAIL] companion '{comp}' NOT FOUND")
                    errors += 1
        except json.JSONDecodeError:
            print("  [FAIL] ctl.json invalid JSON")
            errors += 1

    p()
    if errors == 0:
        print("Validation passed.")
    else:
        print(f"{errors} issue(s) found.")
        sys.exit(1)

# ── Manifest helpers ──────────────────────────────────────────────────────────

def _read_manifest():
    if not MANIFEST_FILE.exists():
        return None
    try:
        return json.loads(MANIFEST_FILE.read_text())
    except Exception:
        return None

def _write_manifest(manifest: dict) -> None:
    MANIFEST_FILE.parent.mkdir(parents=True, exist_ok=True)
    MANIFEST_FILE.write_text(json.dumps(manifest, indent=2) + "\n")

# ── cmd_setup ─────────────────────────────────────────────────────────────────

def cmd_setup(args: list) -> None:
    CLAUDE_DIR      = pathlib.Path.home() / ".claude"
    SETTINGS_FILE   = CLAUDE_DIR / "settings.json"
    STATUSLINE_DEST = CLAUDE_DIR / "statusline-command.sh"
    STATUSLINE_SRC  = INSTALL_DIR / "scripts" / "statusline-command.sh"

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    BACKUP_DIR.mkdir(parents=True, exist_ok=True)
    CLAUDE_DIR.mkdir(parents=True, exist_ok=True)

    manifest = _read_manifest() or {
        "version": "1",
        "backups": {},
        "files_added": [],
        "settings_keys": {},
    }
    manifest["timestamp"] = timestamp
    manifest["kit_ref"] = _git(["rev-parse", "--short", "HEAD"]) or "?"

    p()
    p(f"  {col(C.W, 'claude-kit setup')}")
    p(f"  {col(C.DIM, '─' * 40)}")
    p()

    # ── Statusline ─────────────────────────────────────────────────────────────

    p(f"  {col(C.W, 'Status line')}  {col(C.DIM, 'ctx %, tokens, model in Claude Code footer')}")
    p()

    skip_statusline = False

    if SETTINGS_FILE.exists():
        try:
            settings = json.loads(SETTINGS_FILE.read_text())
            existing_cmd = settings.get("statusLine", {}).get("command", "")
            expected_cmd = f"bash {STATUSLINE_DEST}"
            if existing_cmd and existing_cmd != expected_cmd:
                p(f"  {col(C.Y, '!')} Existing statusLine detected:")
                p(f"      {col(C.DIM, existing_cmd)}")
                p()
                p(f"    {col(C.W, '[o]')} overwrite  {col(C.W, '[s]')} skip  {col(C.DIM, '(default: o)')}")
                choice = input("    Choice: ").strip().lower() or "o"
                if choice == "s":
                    skip_statusline = True
                    p(f"  {col(C.DIM, 'Skipped.')}")
                else:
                    p(f"  {col(C.Y, 'Overwriting — backup created.')}")
                p()
        except Exception:
            pass

    if not skip_statusline:
        # Backup settings.json before first touch
        if SETTINGS_FILE.exists() and str(SETTINGS_FILE) not in manifest["backups"]:
            backup_path = BACKUP_DIR / f"settings.json.{timestamp}"
            shutil.copy2(SETTINGS_FILE, backup_path)
            manifest["backups"][str(SETTINGS_FILE)] = str(backup_path)
            p(f"  {col(C.DIM, f'Backed up settings.json → {backup_path.name}')}")

        # Install script
        shutil.copy2(STATUSLINE_SRC, STATUSLINE_DEST)
        STATUSLINE_DEST.chmod(0o755)
        if str(STATUSLINE_DEST) not in manifest["files_added"]:
            manifest["files_added"].append(str(STATUSLINE_DEST))

        # Update settings.json
        try:
            settings = json.loads(SETTINGS_FILE.read_text()) if SETTINGS_FILE.exists() else {}
        except Exception:
            settings = {}

        settings["statusLine"] = {"type": "command", "command": f"bash {STATUSLINE_DEST}"}
        SETTINGS_FILE.write_text(json.dumps(settings, indent=2) + "\n")

        keys = manifest["settings_keys"].setdefault(str(SETTINGS_FILE), [])
        if "statusLine" not in keys:
            keys.append("statusLine")

        p(f"  {col(C.G, '✓')} Status line installed")
        p()

    _write_manifest(manifest)

    p(f"  {col(C.DIM, '─' * 40)}")
    p(f"  {col(C.G, 'Setup complete.')}")
    p()
    p(f"  Undo anytime:  {col(C.CY, 'claude-kit restore')}")
    p()

# ── cmd_restore ───────────────────────────────────────────────────────────────

def cmd_restore(args: list) -> None:
    manifest = _read_manifest()
    if not manifest:
        p()
        p(f"  {col(C.Y, 'No setup manifest found.')} Nothing to restore.")
        p()
        return

    p()
    p(f"  {col(C.W, 'claude-kit restore')}")
    p(f"  {col(C.DIM, '─' * 40)}")
    p()

    backups       = manifest.get("backups", {})
    files_added   = manifest.get("files_added", [])
    settings_keys = manifest.get("settings_keys", {})

    if not backups and not files_added:
        p(f"  {col(C.DIM, 'Nothing to restore.')}")
        p()
        return

    if backups:
        p(f"  {col(C.W, 'Will restore:')}")
        p()
        for orig, bak in backups.items():
            orig_path = pathlib.Path(orig)
            bak_path  = pathlib.Path(bak)
            keys = settings_keys.get(orig, [])
            keys_str = f"  {col(C.DIM, '(keys: ' + ', '.join(keys) + ')')}" if keys else ""
            p(f"    {col(C.CY, orig_path.name)}{keys_str}")

            # Diff: current vs what we'll restore
            if bak_path.exists() and orig_path.exists():
                try:
                    cur_lines = orig_path.read_text().splitlines(keepends=True)
                    bak_lines = bak_path.read_text().splitlines(keepends=True)
                    diff = list(difflib.unified_diff(
                        cur_lines, bak_lines,
                        fromfile="current", tofile="backup", n=2
                    ))
                    if diff:
                        p(f"    {col(C.DIM, 'Diff (current → backup):')}")
                        for line in diff[:24]:
                            line = line.rstrip("\n")
                            if line.startswith("+") and not line.startswith("+++"):
                                p(f"      {col(C.G, line)}")
                            elif line.startswith("-") and not line.startswith("---"):
                                p(f"      {col(C.R, line)}")
                            else:
                                p(f"      {col(C.DIM, line)}")
                        if len(diff) > 24:
                            p(f"      {col(C.DIM, f'… {len(diff)-24} more lines')}")
                except Exception:
                    pass
            p()

    if files_added:
        p(f"  {col(C.W, 'Will remove:')}")
        p()
        for f in files_added:
            p(f"    {col(C.R, '-')} {f}")
        p()

    confirm = input(f"  {col(C.W, 'Proceed?')} [Y/n] ").strip().lower() or "y"
    if confirm not in ("y", "yes"):
        p()
        p(f"  {col(C.DIM, 'Aborted.')}")
        p()
        return

    p()

    for orig, bak in backups.items():
        orig_path = pathlib.Path(orig)
        bak_path  = pathlib.Path(bak)
        if bak_path.exists():
            shutil.copy2(bak_path, orig_path)
            p(f"  {col(C.G, '✓')} Restored {orig_path.name}")
        else:
            p(f"  {col(C.Y, '!')} Backup not found: {bak_path.name} — skipped")

    for f in files_added:
        fp = pathlib.Path(f)
        if fp.exists():
            fp.unlink()
            p(f"  {col(C.G, '✓')} Removed {fp.name}")

    MANIFEST_FILE.unlink(missing_ok=True)

    p()
    p(f"  {col(C.G, 'Restore complete.')} All setup changes reverted.")
    p()

# ── cmd_uninstall ─────────────────────────────────────────────────────────────

def cmd_uninstall() -> None:
    bin_link = pathlib.Path.home() / ".local" / "bin" / "claude-kit"
    print("This will remove:")
    print(f"  {INSTALL_DIR}  (plugins and CLI)")
    print(f"  {bin_link}  (symlink)")
    p()
    confirm = input("Continue? [y/N] ").strip().lower()
    if confirm not in ("y", "yes"):
        print("Aborted.")
        sys.exit(0)
    if bin_link.is_symlink():
        bin_link.unlink()
        print(f"Removed {bin_link}")
    shutil.rmtree(INSTALL_DIR)
    print(f"Removed {INSTALL_DIR}")
    p()
    print("claude-kit uninstalled.")
    print("Remove the PATH line from your shell rc file if desired.")

# ── cmd_help ──────────────────────────────────────────────────────────────────

def cmd_help() -> None:
    W, CY, DIM = C.W, C.CY, C.DIM
    print(f"""
  {W}claude-kit{C.N}  Claude Code plugin manager

  {DIM}Launch:{C.N}
    {CY}claude-kit --kit <name>{C.N}
    {CY}claude-kit --kit <name> --kit core-spec{C.N}   {DIM}combine kits{C.N}
    {CY}claude-kit --kit <name> --yolo{C.N}               {DIM}skip permission prompts{C.N}
    {CY}claude-kit --kit <name> --model sonnet{C.N}       {DIM}choose model  (default: opus){C.N}

  {DIM}Commands:{C.N}
    {CY}claude-kit setup{C.N}      install Claude Code features with backup
    {CY}claude-kit restore{C.N}    undo setup — restores original files with diff preview
    {CY}claude-kit list{C.N}       show available kits (bundled + local)
    {CY}claude-kit update{C.N}     pull latest plugins, show version changes
    {CY}claude-kit validate{C.N}   check a kit's structure
    {CY}claude-kit uninstall{C.N}  remove claude-kit and the CLI symlink
""")

# ── dispatch ──────────────────────────────────────────────────────────────────

def main() -> None:
    args = sys.argv[1:]

    if not args or args[0] in ("help", "--help", "-h"):
        cmd_help()
        return

    cmd  = args[0]
    rest = args[1:]

    dispatch = {
        "list":      lambda: cmd_list(),
        "update":    lambda: cmd_update(),
        "setup":     lambda: cmd_setup(rest),
        "restore":   lambda: cmd_restore(rest),
        "validate":  lambda: cmd_validate(rest),
        "uninstall": lambda: cmd_uninstall(),
    }

    if cmd in dispatch:
        dispatch[cmd]()
    elif cmd in ("--kit", "-k", "--model", "-m",
                 "--dangerously-skip-permissions", "--yolo", "-y"):
        cmd_run(args)
    elif cmd.startswith("-"):
        print(f"Unknown flag: {cmd}")
        print("Run 'claude-kit help' for usage.")
        sys.exit(1)
    else:
        cmd_run(args)

if __name__ == "__main__":
    main()
